# Phase 3: Framing Layer

**Context:** Building the AA wire format framing for `libs/open-androidauto/`. Phases 1-2 complete — library builds with ITransport, TCPTransport, ReplayTransport.

**Protocol reference:** `~/claude/reference/android-auto-protocol.md`
**Design doc:** `docs/plans/2026-02-23-open-androidauto-design.md` (see "Wire Format" in Messenger section)

## Wire Format Summary

Every AA message is wrapped in frames. Frame structure:
- **Header (2 bytes):** Byte 0 = channelId (uint8), Byte 1 = flags (FrameType bits 1:0, MessageType bit 2, EncryptionType bit 3)
- **Size field:** FIRST frames = 6 bytes (2B frame size BE + 4B total size BE), all others = 2 bytes (frame size BE)
- **Payload:** raw or encrypted bytes

FrameType: MIDDLE=0x00, FIRST=0x01, LAST=0x02, BULK=0x03
EncryptionType: PLAIN=0x00, ENCRYPTED=0x08
MessageType: SPECIFIC=0x00, CONTROL=0x04

Messages <= 16384 bytes = single BULK frame. Larger = FIRST + MIDDLE(s) + LAST.
All sizes are big-endian. After reassembly, payload format is: [messageId (2B BE)] [protobuf data].

---

- [x] **Create FrameType enums and FrameHeader with tests.** Write `include/oaa/Messenger/FrameType.hpp` with three enums in namespace `oaa`: `FrameType` (Middle=0x00, First=0x01, Last=0x02, Bulk=0x03), `EncryptionType` (Plain=0x00, Encrypted=0x08), `MessageType` (Specific=0x00, Control=0x04) — all `enum class : uint8_t`. Write `include/oaa/Messenger/FrameHeader.hpp` with struct `FrameHeader` containing fields: `uint8_t channelId`, `FrameType frameType`, `EncryptionType encryptionType`, `MessageType messageType`. Static methods: `parse(const QByteArray&)` (extract from 2 bytes — byte[0]=channelId, byte[1] masked for each field), `serialize() const` → QByteArray(2 bytes), `sizeFieldLength(FrameType)` → int (First=6, all others=2). Write `src/Messenger/FrameHeader.cpp` with implementations. Write `tests/test_frame_header.cpp` with QtTest: (1) `testParseBulkPlainControl` — bytes {0x00, 0x07} → ch=0, Bulk, Plain, Control. (2) `testParseFirstEncryptedSpecific` — bytes {0x03, 0x09} → ch=3, First, Encrypted, Specific. (3) `testSerialize` — construct header, serialize, verify bytes. (4) `testRoundTrip` — serialize then parse, verify all fields match. (5) `testSizeFieldLength` — First=6, Middle=2, Last=2, Bulk=2. Add sources and test to CMakeLists. Build and run. Commit: `feat(oaa): implement FrameHeader parse/serialize with wire format`

- [x] **Implement FrameSerializer (outgoing message fragmentation) with tests.** Write `include/oaa/Messenger/FrameSerializer.hpp` and `src/Messenger/FrameSerializer.cpp`. Static method `serialize(uint8_t channelId, MessageType msgType, EncryptionType encType, const QByteArray& payload)` → `QList<QByteArray>` (list of complete frames). Logic: if payload.size() <= FRAME_MAX_PAYLOAD (16384), emit single BULK frame: header(2) + size(2B BE, payload.size()) + payload. If larger, emit FIRST frame: header(2, frameType=First) + size(6B: 2B BE chunk size + 4B BE total size) + first 16384 bytes. Then MIDDLE frames for each subsequent 16384-byte chunk. Then LAST frame for remainder. Each MIDDLE/LAST: header(2) + size(2B BE) + chunk. Note: encryption is NOT done here — payload bytes go in as-is. The Messenger layer handles encrypt/decrypt around this. Write `tests/test_frame_serializer.cpp`: (1) `testSmallMessage` — 10-byte payload → 1 frame, verify header bytes (BULK), size field = 10, payload matches. (2) `testExactMaxPayload` — 16384-byte payload → 1 BULK frame. (3) `testOneByteOver` — 16385-byte payload → 2 frames (FIRST + LAST), verify FIRST has 16384 bytes + correct total size in extended header, LAST has 1 byte. (4) `testLargeMessage` — 40000-byte payload → 3 frames (FIRST 16384 + MIDDLE 16384 + LAST 7232), verify frame types and sizes. (5) `testEmptyPayload` — 0-byte payload → 1 BULK frame with size=0. Build and run. Commit: `feat(oaa): implement FrameSerializer for outgoing message fragmentation`

- [ ] **Implement FrameAssembler (incoming frame reassembly) with tests.** Write `include/oaa/Messenger/FrameAssembler.hpp` and `src/Messenger/FrameAssembler.cpp`. QObject with method `onFrame(const FrameHeader& header, const QByteArray& payload)` and signal `messageAssembled(uint8_t channelId, oaa::MessageType messageType, const QByteArray& payload)`. Internal state: `QHash<uint8_t, QByteArray>` mapping channelId → partial payload buffer. Logic: BULK → emit immediately. FIRST → create buffer entry, store payload. MIDDLE → append to existing buffer (if no buffer for this channel, log warning and discard). LAST → append and emit complete message, remove buffer entry. Duplicate FIRST (buffer already exists for channel) → discard old partial, start new. Write `tests/test_frame_assembler.cpp`: (1) `testBulkFrame` — single BULK → messageAssembled with correct payload. (2) `testFirstLast` — FIRST then LAST → one messageAssembled with concatenated payload. (3) `testFirstMiddleLast` — three frames → one complete message. (4) `testInterleavedChannels` — ch3 FIRST, ch4 BULK, ch3 LAST → two complete messages (ch4 first, then ch3). (5) `testMiddleWithoutFirst` — MIDDLE alone → no signal (discarded). (6) `testDuplicateFirst` — FIRST, FIRST → old partial discarded, new one starts. Build and run. Commit: `feat(oaa): implement FrameAssembler with interleaved channel support`

- [ ] **Implement FrameParser (byte stream → frames) with tests.** Write `include/oaa/Messenger/FrameParser.hpp` and `src/Messenger/FrameParser.cpp`. QObject that receives raw bytes via slot `onData(const QByteArray&)` and emits `frameParsed(const oaa::FrameHeader& header, const QByteArray& payload)`. Three-state machine: (1) ReadHeader — accumulate 2 bytes, parse FrameHeader, determine size field length from frameType. (2) ReadSize — accumulate 2 or 6 bytes, parse frame payload size (big-endian uint16 for frame size; for FIRST frames also parse uint32 total size but only use the frame size for this frame's payload). (3) ReadPayload — accumulate frameSize bytes, emit frameParsed(header, payload), reset to ReadHeader. Use a QByteArray buffer internally. When `onData` is called, append to buffer and loop through states consuming bytes until not enough remain. This handles multiple frames in one chunk and partial frames across chunks. Write `tests/test_frame_parser.cpp`: (1) `testCompleteFrame` — feed one complete BULK frame as single chunk → one frameParsed signal. (2) `testByteByByte` — feed BULK frame one byte at a time → one frameParsed after all bytes received. (3) `testTwoFramesOneChunk` — feed two complete BULK frames concatenated → two frameParsed signals. (4) `testSplitAcrossChunks` — feed first 3 bytes of a frame, then remaining bytes → one frameParsed. (5) `testFirstFrameExtendedSize` — feed a FIRST frame (6-byte size field) → verify correct payload extraction. Build and run. Commit: `feat(oaa): implement FrameParser byte-stream to frame decoder`
